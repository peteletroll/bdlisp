;
;	APROPOS.LSP - 1997 - Bigdogs Internescional.
;
;	Funzione apropos
;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(require :pprint)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defparameter *apropos-width* 70)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun native-function-p (sym)
  (or
    (builtinp sym)
    (specialformp sym)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun apropos (str)
  (show-apropos (apropos-list str))
  (values))

(defun show-apropos (lst)
  (princ "\n")
  (dolist (i (list (list "Variables" #'boundp #'apropos-variable)
		   (list "Special forms" #'specialp #'apropos-function)
		   (list "Macros" #'macrop #'apropos-function)
		   (list "Generic functions" #'genericp #'apropos-function)
		   (list "Functions" #'lambdap #'apropos-function)))
    (let ((label (car i)) (filter (cadr i)) (show (caddr i)))
      (let ((filtered (remove-if-not filter lst)))
	(when filtered
	  (apropos-format (concat label ":"))
	  (dolist (sym filtered)
	    (funcall show sym))
	  (princ "\n"))))))

(defun apropos-variable (symbol)
  (apropos-format "  ~s = ~s" symbol (symbol-value symbol))
  (apropos-extra-info symbol))

(defun apropos-function (symbol)
  (format t "  ~a~%" (apropos-lambda-list-string symbol))
  (apropos-extra-info symbol))

(defun apropos-format (format-string &rest args)
  (format t " ~va~%" (- *apropos-width* 4)
	  (truncate-string
	    (apply #'format nil format-string args)
	    (- *apropos-width* 4))))

(defun apropos-extra-info (symbol)
  (let ((doc (get symbol 'documentation))
	(src (get symbol 'source)))
    (when doc
      (apropos-format "    ~a" doc))
    (when (stringp src)
      (apropos-format "    source: ~a" src))))

(defun genericp (sym)
  (get sym 'generic)) 

(defun lambdap (sym)
  (and
    (getd sym)
    (not (macrop sym))
    (not (specialp sym))
    (not (genericp sym))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun find-symbol (sym)
  (show-apropos
    (sort
      (remove-if-not
	#'(lambda (fun)
	    (contains-symbol (getd fun) sym))
	(oblist))))
  (values))

(defun contains-symbol (lst sym)
  (if (atom lst)
    (eq lst sym)
    (or
      (contains-symbol (car lst) sym)
      (contains-symbol (cdr lst) sym))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun apropos-list (str)
  (sort
    (remove-if-not
      #'(lambda (sym)
	  (and
	    (or (getd sym) (boundp sym))
	    (findstr sym str)))
      (oblist))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun apropos-lambda-list-string (sym)
  (unexpand-macro-characters (apropos-lambda-list sym)))

(defun apropos-lambda-list (sym)
  (if (not (symbolp sym))
    nil
    (let ((def (getd sym)))
      (cond
	((null def)
	 nil)
	((native-function-p def)
	 (cons sym (get sym 'lambda-list '(|<???>|))))
	(t
	  (cons sym (remove-&aux (cadr def))))))))

(defun remove-&aux (args)
  (cond
    ((endp args)
     nil)
    ((eq (car args) '&aux)
     nil)
    (t
      (cons (car args) (remove-&aux (cdr args))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun add-lambda-lists (list)
  (dolist (item list)
    (cond
      ((native-function-p (getd (car item)))
       (put (car item) 'lambda-list (cadr item))
       (when (>= (length item) 3)
	 (put (car item) 'documentation (caddr item))))
      (t
	(format t
		"Warning: prototype not needed for ~s~%"
		(car item))))))

(add-lambda-lists '((* (&rest numbers))
		    (+ (&rest numbers))
		    (- (&rest numbers))
		    (/ (&rest numbers))
		    (/= (&rest objects))
		    (1+ (number))
		    (1- (number))
		    (< (&rest objects))
		    (<= (&rest objects))
		    (= (&rest objects))
		    (> (&rest objects))
		    (>= (&rest objects))
		    (abort nil)
		    (abs (number))
		    (acos (number))
		    (adjoin (object list &key (test #'eql)))
		    (and (&rest forms))
		    (append (&rest lists))
		    (apply (closure &rest arglist))
		    (applyhook (closure args evalhook applyhook))
		    (ascii (object))
		    (asin (number))
		    (assoc (key alist &key (test #'eql)))
		    (atan (number))
		    (atan2 (y x))
		    (atom (object))
		    (backquote (template))
		    (boundp (symbol))
		    (break nil)
		    (builtinp (object))
		    (caaar (object))
		    (caadr (object))
		    (caar (object))
		    (cadar (object))
		    (caddr (object))
		    (cadr (object))
		    (car (object))
		    (catch (tag &rest forms))
		    (cdaar (object))
		    (cdadr (object))
		    (cdar (object))
		    (cddar (object))
		    (cdddr (object))
		    (cddr (object))
		    (cdr (object))
		    (ceiling (number))
		    (cgi-decode (string &optional (escape-character "%")))
		    (cgi-encode (string &optional (escape-character "%")))
		    (chdir (string))
		    (clock nil)
		    (close (stream))
		    (closurep (object))
		    (cls nil)
		    (concat (&rest strings))
		    (cond (&rest clauses))
		    (cons (object list))
		    (consp (object))
		    (constantp (object))
		    (copy-list (object))
		    (copy-tree (object))
		    (cos (number))
		    (count (object list &key (test #'eql)))
		    (count-if (test list))
		    (count-if-not (test list))
		    (cursor (row column))
		    (debug-driver nil)
		    (delete (object list &key (test #'eql)))
		    (delete-if (test list))
		    (delete-if-not (test list))
		    (do-loop (&rest forms))
		    (driver nil)
		    (dupstr (string times))
		    (elt (sequence index))
		    (endp (list))
		    (eq (object-1 object-2))
		    (eql (object-1 object-2))
		    (equal (object-1 object-2))
		    (error (format-string &rest objects))
		    (error-exit nil)
		    (eval (object &optional environment))
		    (evalhook (object evalhook applyhook &optional environment))
		    (evenp (number))
		    (exit (&optional (number 0)))
		    (exp (number))
		    (expt (&rest numbers))
		    (feof (stream))
		    (fflush (&optional (stream *standard-output*)))
		    (find (object list &key (test #'eql)))
		    (find-if (test list))
		    (find-if-not (test list))
		    (findstr (string sub &optional (start 0)))
		    (first (object))
		    (floor (number))
		    (fopen (name mode))
		    (format (stream format-string &rest objects))
		    (fread (stream size))
		    (fseek (stream position))
		    (ftell (stream))
		    (funcall (closure &rest arguments))
		    (function (object))
		    (fwrite (stream string))
		    (gcd (&rest numbers))
		    (gensym (&optional (name "g")))
		    (gentemp (&optional (name "t")))
		    (get (symbol property &optional default))
		    (get-decoded-time nil)
		    (get-macro-character (character))
		    (get-output-stream-string (stream))
		    (get-universal-time nil)
		    (getcwd nil)
		    (getd (symbol))
		    (getenv (string))
		    (getplist (symbol))
		    (getprops (symbol))
		    (getvals (symbol))
		    (html-escape (string))
		    (identity (object))
		    (intern (string))
		    (isatty (stream))
		    (keywordp (object))
		    (last (list))
		    (length (sequence))
		    (list (&rest objects))
		    (list* (&rest objects))
		    (listp (object))
		    (load (name &key (verbose t) (print nil)))
		    (log (number))
		    (logand (&rest numbers))
		    (logior (&rest numbers))
		    (logxor (&rest numbers))
		    (lognot (number))
		    (macroexpand (form))
		    (macroexpand-1 (form))
		    (macrop (object))
		    (make-object (type))
		    (make-regexp (string))
		    (make-string-input-stream (string))
		    (make-string-output-stream nil)
		    (make-symbol (string))
		    (make-vector (size &optional initial-element))
		    (makunbound (symbol))
		    (mapc (closure &rest arglists))
		    (mapcan (closure &rest arglists))
		    (mapcar (closure &rest arglists))
		    (mapcon (closure &rest arglists))
		    (mapl (closure &rest arglists))
		    (maplist (closure &rest arglists))
		    (max (&rest objects))
		    (member (object list &key (test #'eql)))
		    (member-if (test list))
		    (member-if-not (test list))
		    (min (&rest objects))
		    (minusp (number))
		    (mkdir (name))
		    (movd (symbol-1 symbol-2))
		    (multiple-value-list (form))
		    (multiple-value-prog1 (&rest forms))
		    (nconc (&rest lists))
		    (neq (object-1 object-2))
		    (neql (object-1 object-2))
		    (nonnull (object))
		    (not (object))
		    (nth (index list))
		    (nthcdr (index list))
		    (null (object))
		    (numberp (object))
		    (object-type (object))
		    (objectp (object))
		    (oblist (&optional by-bucket-flag))
		    (oddp (object))
		    (or (&rest forms))
		    (path-find (name &optional (pathlist *path*)))
		    (peek-char (skip-white-flag &optional (stream *standard-input*)))
		    (plusp (object))
		    (position (object list &key (test #'eql)))
		    (position-if (test list))
		    (position-if-not (test list))
		    (prin1 (object &optional (stream *standard-output*)))
		    (princ (object &optional (stream *standard-output*)))
		    (print (object &optional (stream *standard-output*)))
		    (prog1 (return-form &rest body))
		    (progn (&rest body))
		    (psetq (symbol value &rest more-pairs))
		    (put (symbol property value))
		    (putd (symbol definition))
		    (quote (object))
		    (random (&optional (max 1.0)))
		    (randomize nil)
		    (read (&optional (stream *standard-input*)))
		    (read-char (&optional (stream *standard-input*)))
		    (read-line (&optional (stream *standard-input*)))
		    (reduce (closure arglist))
		    (rem (&rest numbers))
		    (remove (object list &key (test #'eql)))
		    (remove-if (test list))
		    (remove-if-not (test list))
		    (remprop (symbol property))
		    (resize-vector (vector size &optional initial-element))
		    (rest (list))
		    (return (&optional object))
		    (reverse (list))
		    (room nil)
		    (rplaca (cell object))
		    (rplacd (cell object))
		    (second (list))
		    (set (symbol value))
		    (set-macro-character (character closure))
		    (set-vref (vector index value))
		    (setq (symbol value &rest more-pairs))
		    (shell (string))
		    (sin (number))
		    (sort (list &optional (predicate #'<)))
		    (spaces (number &optional (stream *standard-output*)))
		    (specialformp (object))
		    (specialp (symbol))
		    (sqrt (number))
		    (stream-column (stream))
		    (stream-row (stream))
		    (streamp (object))
		    (string-capitalize (string))
		    (string-downcase (string))
		    (string-hash (string))
		    (string-scramble (string))
		    (string-upcase (string))
		    (stringp (object))
		    (substr (string start &optional end))
		    (symbol-name (symbol))
		    (symbol-function (symbol))
		    (symbol-plist (symbol))
		    (symbol-value (symbol))
		    (symbolp (object))
		    (tan (number))
		    (terpri (&optional (stream *standard-output*)))
		    (the-environment nil)
		    (third (list))
		    (throw (tag value))
		    (tokstr (string separators))
		    (type-of (object))
		    (types ())
		    (unintern (symbol))
		    (uniq (lst &key (test #'eql)))
		    (unlink (name))
		    (unread-char (character &optional (stream *standard-input*)))
		    (unwind-protect (form &rest forms))
		    (valid-lambda (object))
		    (valid-lambda-args (object))
		    (values (&rest values))
		    (values-list (list))
		    (vector-list (vector))
		    (vector-size (vector))
		    (vectorp (object))
		    (vref (vector index))
		    (warn (format-string &rest objects))
		    (zerop (object))
		    ))

(when (member :regexp *features*)
  (add-lambda-lists '((re-gmatch (regexp string) "List of matching parts")
		      (re-gsub (regexp replace string) "Global substitution")
		      (re-match (regexp string) "First match")
		      (re-split (regexp string) "Split string with regexp separator")
		      (re-sub (regexp replace string) "Single substitution")
		      )))

(when (member :dynlink *features*)
  (add-lambda-lists '((load-dynamic-library (name &optional (init-function "LISPinitlibrary")))
		      )))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(when (member :popen *features*)
  (add-lambda-lists '((popen (command mode)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(let ((noproto (remove-if-not #'(lambda (symbol) 
				  (and
				    (native-function-p (getd symbol))
				    (neql (substr symbol 0 1) "%")
				    (not (member 'lambda-list (getprops symbol)))))
			      (sort (oblist)))))
  (dolist (sym noproto)
    (format t "Warning: missing prototype for ~s~%" sym)))

(putd 'add-lambda-lists nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(provide :apropos)

